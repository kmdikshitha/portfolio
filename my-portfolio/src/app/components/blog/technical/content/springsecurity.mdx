# Spring Security: Your First Corporate Security Adventure

Picture this: You've just landed your first job at a tech company, and your manager asks you to "add some security to the user login feature." You might be thinking, "Security? Isn't that just checking if the password is correct?" Well, buckle up! We're about to embark on a journey through Spring Security that'll transform you from a security novice to someone who can confidently discuss authentication flows during your next team standup.

## Core concept 1: The Security Nightclub

Imagine a fancy nightclub. There's a bouncer at the door, VIP sections, and different levels of access. Spring Security works exactly like this nightclub's security system, but for your web applications.

### The Big Picture: Authentication vs Authorization

Before we dive deep, let's understand the two main characters in our security story:

**Authentication: "Who are you?"**

- Like showing your ID to the bouncer
- Proving you are who you claim to be
- Username/password, OAuth login, JWT tokens

**Authorization: "What can you do?"**
- Like checking if you have VIP access
- Determining what resources you can access
- Roles, permissions, method-level security

Think of it this way: Authentication gets you through the door, Authorization decides which floors you can access in the building.

## Core concept 2: The Security Filter Chain

In Spring Security, every HTTP request passes through a sequence of filters before reaching your controller. Each filter in the Security Filter Chain has a specific responsibility:

- One filter checks if the user is authenticated
- Another verifies authorization (permissions or roles)
- Others may handle CSRF, CORS, or session validation
```code
// Conceptual flow - not actual code
Request → SecurityFilter1 → SecurityFilter2 → SecurityFilter3 → Your Controller
```
These filters work together in a defined order to ensure the request is secure. If any filter fails the check, the request is stopped and an error is returned. Only after passing all filters is the request forwarded to your controller.

## Core concept 3: SecurityContextHolder, Authentication, and Principal

Spring Security has three core concepts that work together like a well-orchestrated dance:

### 1.  SecurityContextHolder – Holds the Current Security Context

- It’s the thread-local storage that holds the `SecurityContext` for the current request.
- The SecurityContext contains the Authentication object, which represents the currently authenticated user.
- This is used internally by Spring, but you can access it programmatically to get user info if needed.
```java
SecurityContext context = SecurityContextHolder.getContext();
Authentication auth = context.getAuthentication();
```

### 2.  Authentication – Represents the User’s Identity and Status

This interface stores details like:
- Username
- Credentials (usually a password or token)
- Authorities (roles/permissions)
- Whether the user is authenticated
```java
String username = auth.getName();
boolean isAuthenticated = auth.isAuthenticated();
```
It's used internally throughout the filter chain and authorization process. You usually don't create it manually — Spring Security sets it during login.

### 3.  Principal – Represents the Actual User Object
This is the user entity retrieved from the database or authentication provider.

It's available via `auth.getPrincipal()`, and can be:
- A String (username)
- A `UserDetails` object (default implementation)
- Or your custom user object if you implement `UserDetails`

Spring Security handles them internally during the authentication flow:
- You log in → Spring validates credentials.
- Spring builds an Authentication object and stores it in the `SecurityContext`.
- `SecurityContextHolder` makes it accessible across the app (e.g., in controllers, services).

## Setting Up Your Security

As a new developer, you'll encounter three main ways to configure Spring Security. Think of them as three different management styles.

### Path 1: The Simple Manager (application.properties)

```code
# Quick and dirty - like sticky notes on your monitor
spring.security.user.name=admin
spring.security.user.password=secret123
spring.security.user.roles=ADMIN
```
This is great for learning and quick prototypes, but you'll quickly outgrow it in real projects.

### Path 2: The Modern Manager (SecurityFilterChain - Spring Security 6+)

In modern Spring Security, you define a SecurityFilterChain bean. This gives fine-grained control over how requests are secured.

**Key ideas:**

- You configure HttpSecurity using a fluent builder pattern.
- You define who can access what using .authorizeHttpRequests(...).
- You customize the login flow using .formLogin(...).
- Finally, .build() assembles everything into a security filter chain.
```java
@Configuration
@EnableWebSecurity
public class SecurityConfig {
    
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/public/**").permitAll()
                .requestMatchers("/admin/**").hasRole("ADMIN")
                .anyRequest().authenticated()
            )
            .formLogin(form -> form
                .loginPage("/login")
                .defaultSuccessUrl("/dashboard")
            );
        return http.build();
    }
}
```
This is the recommended approach for Spring Security 6 and later.

### Path 3: The Legacy Way (WebSecurityConfigurerAdapter)

Before Spring Security 6, security was configured by extending a base class called WebSecurityConfigurerAdapter.

This class provided hooks like:

- configure(HttpSecurity http) for authorization
- configure(AuthenticationManagerBuilder auth) for in-memory or JDBC-based authentication
```java
// Don't use this in new projects - it's deprecated!
@Configuration
public class OldSecurityConfig extends WebSecurityConfigurerAdapter {
    @Override
    protected void configure(HttpSecurity http) throws Exception {
        // Legacy approach - you might see this in older codebases
    }
}
```
Deprecated in Spring Security 6. Use SecurityFilterChain instead for full modular control.

**Pro Tip:** If you join a company with legacy code using WebSecurityConfigurerAdapter, you'll be the hero who modernizes it to SecurityFilterChain

## Authentication - The Three Ways to Enter the app

### 1.  Username/Password Authentication - The Classic Bouncer
This is the most traditional and widely used approach.

- The user submits a form with a username and password.
- Spring Security verifies the credentials using a UserDetailsService (in-memory, JDBC, or custom).
- If successful, it creates an Authentication object and stores it in the SecurityContext.

```java
@Bean
public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
    http
        .formLogin(form -> form
            .loginPage("/login")
            .usernameParameter("email")     // Custom field names
            .passwordParameter("pwd")
            .defaultSuccessUrl("/dashboard")
            .failureUrl("/login?error=true")
        );
    return http.build();
}
```
**Best for:** Internal enterprise apps, admin panels, login portals

Customizable via formLogin() – change login URLs, parameter names, redirect URLs, etc.

### 2.  OAuth2 Login – The VIP Guest List
OAuth2 allows users to authenticate via third-party providers (Google, GitHub, Facebook).

- Spring redirects the user to the provider’s login screen.
- On success, it receives a token and user profile.
- The user is now authenticated in your app without storing a password.
```java
@Bean
public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
    http
        .oauth2Login(oauth -> oauth
            .loginPage("/oauth2/authorization/google")
            .defaultSuccessUrl("/dashboard")
        );
    return http.build();
}

# application.yml
spring:
  security:
    oauth2:
      client:
        registration:
          google:
            client-id: your-google-client-id
            client-secret: your-google-client-secret
```

**Best for:** SaaS apps, external user bases, seamless sign-ins

Configured in application.yml with `client-id` and `client-secret`.

![Spring Security](/blog/thumbnail/springsecurity.png)

### 3.  JWT Authentication – The Secret Handshake

JWT (JSON Web Token) is a stateless token-based mechanism ideal for APIs.

- The client logs in once and receives a signed JWT.
- On every request, the client sends the token (usually in Authorization header).
- A custom filter validates the token and loads the user context.
```java
@Component
public class JwtAuthenticationFilter extends OncePerRequestFilter {
    
    @Override
    protected void doFilterInternal(HttpServletRequest request, 
                                  HttpServletResponse response, 
                                  FilterChain filterChain) throws ServletException, IOException {
        
        String token = extractTokenFromRequest(request);
        
        if (token != null && jwtUtil.validateToken(token)) {
            String username = jwtUtil.getUsernameFromToken(token);
            // Create authentication object and set in SecurityContext
        }
        
        filterChain.doFilter(request, response);
    }
}
```
- **Best for:** SPAs, mobile apps, microservices
- Requires a OncePerRequestFilter and a secure token utility (jwtUtil)

## Authorization - What can you do in the app?

There are majorly two ways to configure this.

### 1.  Role-Based Access Control (RBAC) – Controlling Access by Roles

Spring Security allows you to restrict access based on user roles. Roles are typically strings like `ADMIN`, `USER`, `MANAGER`, and are attached to authenticated users.
```java
.requestMatchers("/admin/**").hasRole("ADMIN")
```
**What It Does:**
Only users with the role ADMIN can access any URL starting with /admin/.

You can:

- Allow multiple roles with .hasAnyRole("ADMIN", "MANAGER")
- Make certain endpoints public with .permitAll()

RBAC keeps your application secure by only allowing users access to what their role permits.

### 2.  Method-Level Security – Fine-Grained Access Control

Sometimes URL-level security isn't enough. You want to secure individual service methods. Spring supports that via annotations:

- `@PreAuthorize`: Runs a SpEL expression before the method is invoked.
```java
@PreAuthorize("hasRole('ADMIN') or #id == authentication.principal.id")
```
- `@Secured`: A simpler alternative for basic role checks.
```java
@Secured("ROLE_MANAGER")
```
- `@RolesAllowed`: Standard Java annotation (JSR-250) for multi-role access.
```java
@RolesAllowed({"ADMIN", "AUDITOR"})
```

This must be added to a config class to activate method-level annotations.
`@EnableMethodSecurity(prePostEnabled = true, securedEnabled = true, jsr250Enabled = true)`

Together, these strategies allow Spring developers to control access declaratively at both the URL and method levels—ensuring enterprise-grade security in multi-role systems.

## Stateless vs Stateful Security – Understanding the Trade-offs 

### 1.  Stateful Sessions – Traditional Web Login

Stateful security means the server remembers the user across requests using a session.

- After login, a session is created and stored on the server.
- The client stores a session ID (usually in a cookie) and sends it with every request.
- The server validates the session ID and retrieves user info from memory.
```java
.sessionManagement(session -> session
    .sessionCreationPolicy(SessionCreationPolicy.IF_REQUIRED)
    .maximumSessions(1)
)
```
Best for:

- Web apps with forms
- Server-rendered UI (Thymeleaf, JSP)
- Applications requiring login/logout and session tracking

### 2.  Stateless Authentication – Token-Based (e.g., JWT)
In stateless security, each request carries all the information needed to authenticate.

- No server-side session is maintained.
- The client sends a JWT token on each request (typically in the Authorization header).
- The server validates the token and processes the request accordingly.
```java
.sessionManagement(session -> session
    .sessionCreationPolicy(SessionCreationPolicy.STATELESS)
)
.addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class);
```
Best for:

- REST APIs
- Mobile apps
- Microservices

JWTs are self-contained authentication tokens signed by the server.

**Structure:**
- Header: Metadata about the token type and signing algorithm
- Payload: Claims like username, roles, and expiry
- Signature: Ensures the token hasn’t been tampered with

**Key Operations**:
```java
// Generate token
generateToken(UserDetails userDetails): signs and encodes user info

// Validate token
validateToken(String token): verifies signature and expiration
```

## Password Management in Spring Security

Storing passwords safely is one of the most critical responsibilities in application development. Spring Security makes it easy and secure using BCrypt.

Plain passwords in a database are a disaster waiting to happen. Even with database encryption, once compromised, raw passwords can be leaked and reused elsewhere.

Instead, we use one-way hashing algorithms that convert the password into an irreversible, secure format.

BCrypt is a hashing function built specifically for password storage:

- **Salting:** Automatically adds a unique random value to each password before hashing.
- **One-way:** The original password cannot be retrieved from the hash.
- **Adaptive Cost Factor:** You can increase the complexity over time as computing power grows.

To use it, you define a `PasswordEncoder` bean:
```java
@Configuration
public class SecurityConfig {
    
    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder(12); // Strength level (higher = slower)
    }
}
```
Use below to hash user passwords before storing them in the database.

To verify a login attempt:
```java
passwordEncoder.matches(rawPassword, storedHashedPassword);
```
Spring Security handles this under the hood during login if you wire it into your `UserDetailsService`.

## Common Pitfalls

Even seasoned developers trip over Spring Security’s powerful (but sometimes tricky) defaults. Let’s walk through three common missteps that new devs make—and how to avoid them like a pro.

### 1.  The CSRF Confusion – Why is My API Failing?

**The Problem:**

By default, Spring Security enables **CSRF (Cross-Site Request Forgery)** protection for all POST, PUT, PATCH, and DELETE requests. While this is great for browser-based apps, it breaks REST APIs, especially if you're using tools like Postman or a JavaScript frontend.

**The Fix:**

Tell Spring to ignore CSRF for your API endpoints. Also, if you're building a form-based web app, use a CookieCsrfTokenRepository for token propagation.
```java
@Bean
public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
    http
        .csrf(csrf -> csrf
            .csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse())
            .ignoringRequestMatchers("/api/**")  // Disable for API
        );
    return http.build();
}
```
### 2.  The CORS Catastrophe – “Why Can’t My Frontend Talk to My Backend?”

**The Problem:**

Your frontend (React, Angular, etc.) sends a request... and your backend silently blocks it. That’s CORS (Cross-Origin Resource Sharing) at work.

**The Fix:**

Spring Security doesn't enable CORS by default. You need to explicitly configure it using a CorsConfigurationSource.
```java
@Bean
public CorsConfigurationSource corsConfigurationSource() {
    CorsConfiguration config = new CorsConfiguration();
    config.setAllowedOrigins(List.of("http://localhost:3000"));
    config.setAllowedMethods(List.of("GET", "POST", "PUT", "DELETE"));
    config.setAllowedHeaders(List.of("*"));
    config.setAllowCredentials(true);

    UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
    source.registerCorsConfiguration("/**", config);
    return source;
}
```
Then wire it into your filter chain:
`http.cors(cors -> cors.configurationSource(corsConfigurationSource()));`

### 3.  The Static Resource Trap – “Where Did My CSS Go?”

**The Problem:**
Your login page loads... but it looks like it’s from the 90s. CSS and JS are being blocked by Spring Security.

**The Fix:**
Explicitly permit static resource paths (/css/**, /js/**, /images/**) in your authorizeHttpRequests() section:
```java
http.authorizeHttpRequests(auth -> auth
    .requestMatchers("/css/**", "/js/**", "/images/**").permitAll()
    .requestMatchers("/", "/home", "/about").permitAll()
    .anyRequest().authenticated()
);
```

Spring Security is opinionated and secure by default—but that means you need to configure exceptions consciously. Most of the time, the "errors" aren't bugs, they’re just misunderstood defaults.

Catch these rookie mistakes early, and you'll look like a seasoned Spring pro in your next code review.


## Wrapping Up

You've just completed your crash course in Spring Security. You now understand the difference between authentication and authorization, know how to configure security in modern Spring applications, and most importantly, you're aware of the common pitfalls that trip up new developers.

Remember, security is not a destination—it's a journey. Every corporate environment will have its own requirements, standards, and challenges. The concepts you've learned here are your foundation, but stay curious, keep learning, and don't be afraid to ask questions during code reviews.
